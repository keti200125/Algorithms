# Задачата за опашката

Пред каса за билети има опашка от n човека: h1,..,hn , 1<=i<=n
Знаем, че hi ще се забави di минути на касата.
Съседите в опашката може да се комбинират и пазаруват заедно и това може да отнеме ci минути за hi и hi+1
При дадени d1,...,dn и c1,...,cn-1:
1) Да се пресметне МИНИМАЛНОТО време, за което цялата опашка може да си купи билетите.
2) Да се намери кой с кого трябва да се комбинира, за да е МИНИМАЛНО времето

* Решение: 
1) 
   
   Сложност по време: Θ(n)
   
 Разглеждаме последователно редиците S1 = {h1}, S2 = {h1,h2}, ..., Sn={h1,...,hn}
    
Ще се опитаме да намерим оптимума за sk чрез оптимумите за sk-1, sk-1, ..., s1. Тогава оптимумът за sn е търсеният отговор.
```python
s1 = d1, 
s2 = min{d1+d2,c1}, 
s3 = min{s2 + d3, s1+c2} , третият човек може или да
мине индивидуално, или да се комбинира с втория
s4 = min{s3+d4,s2+c3}
```
Тоест
```python
opt(si) = d1,                                    i=1  
opt(si) = min{d1+d2,c2},                         i=2
opt(si) = min{opt(si-1) + di, opt(si-2) + ci-1}, i>=3 
```
За по-удобно за нашия алгоритъм ще използваме конструкцията:
 ```python
 opt(si) = 0,                                     i=0 
 opt(si) = d1,                                    i=1 
 opt(si) = min{opt(si-1) + di, opt(si-2) + ci-1}, i>=2
 ```
2) 
 След получаването на opt(n), проследяваме отдясно
наляво веригата от индекси и това дава едно оптимално решение. Такова проследяване се нарича traceback(обратно проследяване). 

# Числата на Фибоначи

      Fn = 0 ,           n=0
      Fn = 1 ,           n=1
      Fn = Fn-1 + Fn-2 , n>1
Ако имплементираме това рекурентно уравнение като рекурсивна програма директно, дървото на рекурсията става много голямо за по-големи стойности. Възможно е дори да имаме пробем с представянето за много големи числа.  

Искаме да използваме алгоритъм по схемата ДП. Тоест да изчисляваме като помним предходните стойности. Така не се извършват допълнителни пресмятания. 
  
Сложност по време: Θ(n)

# Боядисване на къщи в редица

Дадени са n къщи h1, h2, . . . , hn, които са една до друга в редица в този ред. Всяка
къща трябва да бъде боядисана в един от цветовете червен(r), зелен(g) или син(b). Никои две съседни
къщи не трябва да са в един и същи цвят. За всяко i= 1, ..., n са известни: 
```python
• цената cr[i] за боядисване на hi в червен цвят
• цената cg[i] за боядисване на hi в зелен цвят
• цената cb[i] за боядисване на hi в син цвят

```
Иска се колкото е възможно по-ефикасен алгоритъм за изчисляване на МИНИМАЛНАТА цена
за боядисване на всички къщи. 
* Има линейна наредба върху къщите.
* Няма посока върху линейната наредба на къщите, така че
можем да разсъждаваме от който искаме край в посока към другия край. За определеност, ще разсъждаваме с hn. Очевидно, hn трябва да бъде боядисана в червено, зелено или синьо:
    ```python
     • Ако hn e в червено, min цена за всички къщи е cr[n] + min цена за боядисване на h1, ... ,hn , като hn може да е зелена или синя,но не и червена
     • Ако hn е в зелено, min цена за всички къщи е cg[n] + min цена за боядисване на h1,...,hn , като hn може да е червена или синя, но не и зелена
     • Ако hn е в синьо, min цена за всички къщи е cb[n] + min цена за боядисване на h1,...,hn , като hn може да е червена или зелена, но не и синя
    ```
Нека optr[i] е минималната цена за боядисване на къщи h1,...,hi по такъв начин, че hi е червена. Нека optg[i] е минималната цена за боядисване на къщи h1,...,hi по такъв начин, че hi е зелена. Нека optb[i] е минималната цена за боядисване на къщи h1,...,hi по такъв начин, че hi е синя. Използвайки тези нотации, можем да препишем горните разсъждения
така: 
```python
• Ако hn е червена, минималната цена за всички къщи е cr[n]+ 
min{optg[n-1],optb[n-1]}
• Ако hn е зелена, минималната цена за всички къщи е cg[n]+ 
min{optr[n-1],optb[n-1]}
• Ако hn е синя, минималната цена за всички къщи е cb[n]+ 
min{optr[n-1],optg[n-1]}
```
Рекурсивна декомпозиция:
```python
optr[1] = cr[1]
optg[1] = cg[1]
optb[1] = cb[1]
optr[i] = cr[i]+min{optg[i-1],optb[i-1]}, i>=2
optg[i] = cg[i]+min{optr[i-1],optb[i-1]}, i>=2
optb[i] = cb[i]+min{optg[i-1],optr[i-1]}, i>=2
```
Търсеният отговор е:
```python
min{optr[n],optg[n],optb[n]}
```
Сложност по време и памет: Θ(n)







 
